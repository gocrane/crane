<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crane – 核心概念</title><link>/zh-cn/docs/core-concept/</link><description>Recent content in 核心概念 on Crane</description><generator>Hugo -- gohugo.io</generator><atom:link href="/zh-cn/docs/core-concept/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: 应用资源优化模型</title><link>/zh-cn/docs/core-concept/resource-optimize-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/core-concept/resource-optimize-model/</guid><description>
&lt;p>资源优化是 FinOps 中常见的优化手段，我们基于 Kubernetes 应用的特点总结出云原生应用的&lt;strong>资源优化模型&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="/images/resource-model.png" alt="Resource Model">&lt;/p>
&lt;p>图中五条线从上到下分别是：&lt;/p>
&lt;ol>
&lt;li>节点容量：集群中所有节点的资源总量，对应集群的 Capacity&lt;/li>
&lt;li>已分配：应用申请的资源总量，对应 Pod Request&lt;/li>
&lt;li>周峰值：应用在过去一段时间内资源用量的峰值。周峰值可以预测未来一段时间内的资源使用，通过周峰值配置资源规格的安全性较高，普适性更强&lt;/li>
&lt;li>日均峰值：应用在近一天内资源用量的峰值&lt;/li>
&lt;li>均值：应用的平均资源用量，对应 Usage&lt;/li>
&lt;/ol>
&lt;p>其中资源的闲置分两类：&lt;/p>
&lt;ol>
&lt;li>Resource Slack：Capacity 和 Request 之间的差值&lt;/li>
&lt;li>Usage Slack：Request 和 Usage 之间的差值&lt;/li>
&lt;/ol>
&lt;p>Total Slack = Resource Slack + Usage Slack&lt;/p>
&lt;p>资源优化的目标是 &lt;strong>减少 Resource Slack 和 Usage Slack&lt;/strong>。模型中针对如何一步步减少浪费提供了四个步骤，从上到下分别是：&lt;/p>
&lt;ol>
&lt;li>提升装箱率：提升装箱率能够让 Capacity 和 Request 更加接近。手段有很多，例如：&lt;a href="/zh-cn/docs/tutorials/scheduling-pods-based-on-actual-node-load">动态调度器&lt;/a>、腾讯云的云原生节点的节点放大功能等&lt;/li>
&lt;li>业务规格调整减少资源锁定：根据周峰值资源用量调整业务规格使的 Request 可以减少到周峰值线。&lt;a href="/zh-cn/docs/tutorials/recommendation/resource-recommendation">资源推荐&lt;/a>和&lt;a href="/zh-cn/docs/tutorials/recommendation/replicas-recommendation">副本推荐&lt;/a>可以帮助应用实现此目标。&lt;/li>
&lt;li>业务规格调整+扩缩容兜底流量突发：在规格优化的基础上再通过 HPA 兜底突发流量使的 Request 可以减少到日均峰值线。此时 HPA 的目标利用率偏低，仅为应对突发流量，绝大多数时间内不发生自动弹性。&lt;a href="/zh-cn/docs/tutorials/recommendation/hpa-recommendation">弹性推荐&lt;/a>可以扫描出适合做弹性的应用并提供HPA配置。&lt;/li>
&lt;li>业务规格调整+扩缩容应对日常流量变化：在规格优化的基础上再通过 HPA 应用日常流量使的 Request 可以减少到均值。此时 HPA 的目标利用率等于应用的平均利用率。&lt;a href="/zh-cn/docs/tutorials/using-effective-hpa-to-scaling-with-effectiveness">EHPA&lt;/a>实现了基于预测的水平弹性，帮助更多应用实现智能弹性。&lt;/li>
&lt;/ol></description></item><item><title>Docs: 时间序列预测算法-DSP</title><link>/zh-cn/docs/core-concept/timeseries-forecasting-by-dsp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/core-concept/timeseries-forecasting-by-dsp/</guid><description>
&lt;p>时间序列预测是指使用过去的时间序列数据来预测未来的值。时间序列数据通常包括时间和相应的数值，例如资源用量、股票价格或气温。时间序列预测算法 DSP（Digital Signal Processing）是一种数字信号处理技术，可以用于分析和处理时间序列数据。&lt;/p>
&lt;p>离散傅里叶变换（DFT）就是DSP领域常用的一种算法。DFT是一种将时域信号转换为频域信号的技术。通过将时域信号分解成不同的频率成分，可以更好地理解和分析信号的特征和结构。在时间序列预测中，DFT可以用于分析和预测信号的周期性和趋势性，从而提高预测的准确性。&lt;/p>
&lt;p>Crane使用在数字信号处理（Digital Signal Processing）领域中常用的的&lt;code>离散傅里叶变换&lt;/code>、&lt;code>自相关函数&lt;/code>等手段，识别、预测周期性的时间序列。&lt;/p>
&lt;p>本文将介绍DSP算法的实现流程和参数设置，以便帮助大家了解算法背后的原理，并将它应用到实际场景中。 （相关代码位于&lt;code>pkg/prediction/dsp&lt;/code>目录下）&lt;/p>
&lt;h2 id="流程">流程&lt;/h2>
&lt;p>&lt;img src="/images/algorithm/dsp/dsp.png" alt="">&lt;/p>
&lt;h3 id="预处理">预处理&lt;/h3>
&lt;h4 id="填充缺失数据">填充缺失数据&lt;/h4>
&lt;p>监控数据在某些时间点上缺失是很常见的现象，Crane会根据前后的数据对缺失的采样点进行填充。做法如下：&lt;/p>
&lt;p>假设第\(m\)个与第\(n\)个采样点之间采样数据缺失（\(m+1 &amp;lt; n\)）,设在\(m\)和\(n\)点的采样值分别为\(v_m\)和\(v_n\)，令$$\Delta = {v_n-v_m \over n-m}$$，则\(m\)和\(n\)之间的填充数据依次为$$v_m+\Delta , v_m+2\Delta , &amp;hellip;$$&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/missing_data_fill.png" alt="">&lt;/p>
&lt;h4 id="去除异常点">去除异常点&lt;/h4>
&lt;p>监控数据中偶尔会出现一些极端的异常数据点，导致这些异常点（outliers）的原因有很多，例如：&lt;/p>
&lt;ol>
&lt;li>监控系统用0值填充缺失的采样点；&lt;/li>
&lt;li>被监控组件由于自身的bug上报了错误的指标数据；&lt;/li>
&lt;li>应用启动时会消耗远超正常运行时的资源&lt;/li>
&lt;/ol>
&lt;p>这些极端的异常点对于信号的周期判断会造成干扰，需要进行去除。做法如下：&lt;/p>
&lt;p>选取实际序列中所有采样点的\(P99.9\)和\(P0.1\)，分别作为上、下限阈值，如果某个采样值低于下限或者高于上限，将采样点的值设置为前一个采样值。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/remove_outliers.png" alt="">&lt;/p>
&lt;h4 id="离散傅里叶变换">离散傅里叶变换&lt;/h4>
&lt;p>对监控的时间序列（设长度为\(N\)）做快速离散傅里叶变换（FFT），得到信号的频谱图（spectrogram），频谱图直观地表现为在各个离散点\(k\)处的「冲击」。
冲击的高度为\(k\)对应周期分量的「幅度」，\(k\)的取值范围\((0,1,2, &amp;hellip; N-1)\)。&lt;/p>
&lt;p>\(k = 0\)对应信号的「直流分量」，对于周期没有影响，因此忽略。&lt;/p>
&lt;p>由于离散傅里叶变换后的频谱序列前一半和后一半是共轭对称的，反映到频谱图上就是关于轴对称，因此只看前一半\(N/2\)即可。&lt;/p>
&lt;p>\(k\)所对应的周期$$T = {N \over k} \bullet SampleInterval$$&lt;/p>
&lt;p>要观察一个信号是不是以\(T\)为周期，至少需要观察两倍的\(T\)的长度，因此通过长度为\(N\)的序列能够识别出的最长周期为\(N/2\)。所以可以忽略\(k = 1\)。&lt;/p>
&lt;p>至此，\(k\)的取值范围为\((2, 3, &amp;hellip; , N/2)\)，对应的周期为\(N/2, N/3, &amp;hellip;\)，这也就是FFT能够提供的周期信息的「分辨率」。如果一个信号的周期没有落到\(N/k\)上，它会散布到整个频域，导致「频率泄漏」。
好在在实际生产环境中，我们通常遇到的应用（尤其是在线业务），如果有规律，都是以「天」为周期的，某些业务可能会有所谓的「周末」效应，即周末和工作日不太一样，如果扩大到「周」的粒度去观察，它们同样具有良好的周期性。&lt;/p>
&lt;p>Crane没有尝试发现任意长度的周期，而是指定几个固定的周期长度（\(1d、7d\)）去判断。并通过截取、填充的方式，保证序列的长度\(N\)为待检测周期\(T\)的整倍数，例如：$$T=1d，N=3d；T=7d，N=14d$$。&lt;/p>
&lt;p>我们从生产环境中抓取了一些应用的监控指标，保存为csv格式，放到&lt;code>pkg/prediction/dsp/test_data&lt;/code>目录下。
例如，&lt;code>input0.csv&lt;/code>文件包括了一个应用连续8天的CPU监控数据，对应的时间序列如下图：&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/input0.png" alt="">&lt;/p>
&lt;p>我们看到，尽管每天的数据不尽相同，但大体「模式」还是基本一致的。&lt;/p>
&lt;p>对它做FFT，会得到下面的频谱图：&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/spectrum.png" alt="">&lt;/p>
&lt;p>我们发现在几个点上的「幅值」明显高于其它点，这些点便可以作为我们的「候选周期」，待进一步的验证。&lt;/p>
&lt;p>上面是我们通过直觉判断的，Crane是如何挑选「候选周期」的呢？&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对原始序列\(\vec x(n)\)进行一个随机排列后得到序列\(\vec x&amp;rsquo;(n)\)，再对\(\vec x&amp;rsquo;(n)\)做FFT得到\(\vec X&amp;rsquo;(k)\)，令\(P_{max} = argmax|\vec X&amp;rsquo;(k)|\)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重复100次上述操作，得到100个\(P_{max}\)，取\(P99\)作为阈值\(P_{threshold}\)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对原始序列\(\vec x(n)\)做FFT得到\(\vec X(f)\)，遍历\(k = 2, 3, &amp;hellip;\)，如果\(P_k = |X(k)| &amp;gt; P_{threshold}\)，则将\(k\)加入候选周期。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="循环自相关函数">循环自相关函数&lt;/h4>
&lt;p>自相关函数（Auto Correlation Function，ACF）是一个信号于其自身在不同时间点的互相关。通俗的讲，它就是两次观察之间的相似度对它们之间的时间差的函数。&lt;/p>
&lt;p>Crane使用循环自相关函数（Circular ACF），先对长度为\(N\)的时间序列以\(N\)为周期做扩展，也就是在\(&amp;hellip;, [-N, -1], [N, 2N-1], &amp;hellip;\)区间上复制\(\vec x(n)\)，得到一个新的序列\(\vec x&amp;rsquo;(n)\)。
再依次计算将\(\vec x&amp;rsquo;(n)\)依次平移\(k=1,2,3,&amp;hellip;N/2\)后的\(\vec x&amp;rsquo;(n+k)\)与\(\vec x&amp;rsquo;(n)\)的相关系数&lt;/p>
&lt;p>$$r_k={\displaystyle\sum_{i=-k}^{N-k-1} (x_i-\mu)(x_{i+k}-\mu) \over \displaystyle\sum_{i=0}^{N-1} (x_i-\mu)^2}\ \ \ \mu: mean$$&lt;/p>
&lt;p>Crane没有直接使用上面的定义去计算ACF，而是根据下面的公式，通过两次\((I)FFT\)，从而能够在\(O(nlogn)\)的时间内完成ACF的计算。
$$\vec r = IFFT(|FFT({\vec x - \mu \over \sigma})|^2)\ \ \ \mu: mean,\ \sigma: standard\ deviation$$&lt;/p>
&lt;p>ACF的图像如下所示，横轴代表信号平移的时间长度\(k\)；纵轴代表自相关系数\(r_k\)，反应了平移信号与原始信号的「相似」程度。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/acf.png" alt="">&lt;/p>
&lt;p>Crane会依次验证每一个候选周期对应的自相关系数是否位于「山顶」上；并且选择对应「最高峰」的那个候选周期为整个时间序列的主周期（基波周期），并以此为基础进行预测。&lt;/p>
&lt;p>如何判断「山顶」？&lt;/p>
&lt;p>Crane在两侧个各选取一段曲线，分别做线性回归，当回归后左、右的直线斜率分别大于、小于零时，则认为这个点是在一个「山顶」上。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/linear_regression.png" alt="">&lt;/p>
&lt;h4 id="预测">预测&lt;/h4>
&lt;p>根据上一步得到的主周期，Crane提供了两种方式去拟合（预测）下一个周期的时序数据
&lt;strong>maxValue&lt;/strong>&lt;/p>
&lt;p>选取过去几个周期中相同时刻\(t\)（例如：下午6:00）中的最大值，作为下一个周期\(t\)时刻的预测值。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/max_value.png" alt="">
&lt;strong>fft&lt;/strong>&lt;/p>
&lt;p>对原始时间序列做FFT得到频谱序列，去除「高频噪声」后，再做IFFT（逆快速傅里叶变换），将得到的时间序列作为下一个周期的预测结果。&lt;/p>
&lt;h2 id="应用">应用&lt;/h2>
&lt;p>Crane提供了&lt;code>TimeSeriesPrediction&lt;/code>，通过这个CRD，用户可以对各种时间序列进行预测，例如工作负责的CPU利用率、应用的QPS等等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">prediction.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">TimeSeriesPrediction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">tsp-workload-dsp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionWindowSeconds&lt;/span>: &lt;span style="color:#ae81ff">7200&lt;/span> &lt;span style="color:#75715e"># 提供未来7200秒（2小时）的预测数据。Crane会把预测数据写到status中。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionMetrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">resourceIdentifier&lt;/span>: &lt;span style="color:#ae81ff">workload-cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">ExpressionQuery&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expressionQuery&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expression&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;sum (irate (container_cpu_usage_seconds_total{container!=&amp;#34;&amp;#34;,image!=&amp;#34;&amp;#34;,container!=&amp;#34;POD&amp;#34;,pod=~&amp;#34;^test-.*$&amp;#34;}[1m]))&amp;#39;&lt;/span> &lt;span style="color:#75715e"># 获取历史监控数据的查询语句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithm&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithmType&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;dsp&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 指定dsp为预测算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dsp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sampleInterval&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;60s&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 监控数据的采样间隔为1分钟&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">historyLength&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;15d&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 拉取过去15天的监控指标作为预测的依据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">estimators&lt;/span>: &lt;span style="color:#75715e"># 指定预测方式，包括&amp;#39;maxValue&amp;#39;和&amp;#39;fft&amp;#39;，每一类可以指定多个estimator，配置不同的参数，crane会选取一个拟合度最高的去产生预测结果。如果不指定的话，默认使用&amp;#39;fft&amp;#39;。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># maxValue:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># - marginFraction: &amp;#34;0.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fft&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">marginFraction&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">lowAmplitudeThreshold&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">highFrequencyThreshold&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.05&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">minNumOfSpectrumItems&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxNumOfSpectrumItems&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面示例中的一些dsp参数含义如下：&lt;/p>
&lt;p>&lt;strong>maxValue&lt;/strong>&lt;/p>
&lt;p>&lt;code>marginFraction&lt;/code>: 拟合出下一个周期的序列后，将每一个预测值乘以&lt;code>1 + marginFraction&lt;/code>，例如&lt;code>marginFraction = 0.1&lt;/code>,就是乘以1.1。&lt;code>marginFraction&lt;/code>的作用是将预测数据进行一定比例的放大（或缩小）。&lt;/p>
&lt;p>&lt;strong>fft&lt;/strong>&lt;/p>
&lt;p>&lt;code>marginFraction&lt;/code>: 拟合出下一个周期的序列后，将每一个预测值乘以&lt;code>1 + marginFraction&lt;/code>，例如&lt;code>marginFraction = 0.1&lt;/code>,就是乘以1.1。&lt;code>marginFraction&lt;/code>的作用是将预测数据进行一定比例的放大（或缩小）。&lt;/p>
&lt;p>&lt;code>lowAmplitudeThreshold&lt;/code>: 频谱幅度下限，所有幅度低于这个下限的频率分量将被滤除。&lt;/p>
&lt;p>&lt;code>highFrequencyThreshold&lt;/code>: 频率上限，所有频率高于这个上限的频率分量将被滤除。单位Hz，例如如果想忽略长度小于1小时的周期分量，设置&lt;code>highFrequencyThreshold = 1/3600&lt;/code>。&lt;/p>
&lt;p>&lt;code>minNumOfSpectrumItems&lt;/code>: 至少保留频率分量的个数。&lt;/p>
&lt;p>&lt;code>maxNumOfSpectrumItems&lt;/code>：至多保留频率分量的个数。&lt;/p>
&lt;p>简单来说，保留频率分量的数量越少、频率上限越低、频谱幅度下限越高，预测出来的曲线越光滑，但会丢失一些细节；反之，曲线毛刺越多，保留更多细节。&lt;/p>
&lt;p>下面是对同一时段预测的两条曲线，蓝色、绿色的&lt;code>highFrequencyThreshold&lt;/code>分别为\(0.01\)和\(0.001\)，蓝色曲线过滤掉了更多的高频分量，因此更为平滑。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/lft_0_001.png" alt=""> &lt;img src="/images/algorithm/dsp/lft_0_01.png" alt="">&lt;/p>
&lt;p>并没有一套参数配置适合所有的时间序列，通常需要根据应用指标的特点，去调整算法参数，以期获得最佳的预测效果。
Crane提供了一个web接口，使用者可以在调整参数后，直观的看到预测效果，使用步骤如下：&lt;/p>
&lt;ol>
&lt;li>修改&lt;code>TimeSeriesPrediction&lt;/code>中的&lt;code>estimators&lt;/code>的参数。&lt;/li>
&lt;li>访问craned http server的&lt;code>api/prediction/debug/&amp;lt;namespace&amp;gt;/&amp;lt;timeseries prediction name&amp;gt;&lt;/code>，查看参数效果（如下图）。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="/images/algorithm/dsp/dsp_debug.png" alt="">&lt;/p>
&lt;p>上述步骤可多次执行，直到得到满意的预测效果。&lt;/p>
&lt;p>&lt;strong>通过port-forward进行本地调试&lt;/strong>&lt;/p>
&lt;p>craned http server的端口通过craned启动参数&lt;code>--server-bind-port&lt;/code>设置，默认为&lt;code>8082&lt;/code>。&lt;/p>
&lt;p>打开终端，&lt;/p>
&lt;pre tabindex="0">&lt;code>$kubectl -n crane-system port-forward service/craned 8082:8082
Forwarding from 127.0.0.1:8082 -&amp;gt; 8082
Forwarding from [::1]:8082 -&amp;gt; 8082
&lt;/code>&lt;/pre>&lt;p>打开浏览器，访问&lt;code>http://localhost:8082/api/prediction/debug/&amp;lt;namespace&amp;gt;/&amp;lt;timeseries prediction name&amp;gt;&lt;/code>&lt;/p></description></item><item><title>Docs: 系统架构</title><link>/zh-cn/docs/core-concept/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/zh-cn/docs/core-concept/architecture/</guid><description>
&lt;p>Crane 的整体架构如下：&lt;/p>
&lt;p>&lt;img src="/images/crane-arch.png" alt="Crane Arch">&lt;/p>
&lt;p>&lt;strong>Craned&lt;/strong>&lt;/p>
&lt;p>Craned 是 Crane 的最核心组件，它管理了 CRDs 的生命周期以及API。Craned 通过 &lt;code>Deployment&lt;/code> 方式部署且由两个容器组成：&lt;/p>
&lt;ul>
&lt;li>Craned: 运行了 Operators 用来管理 CRDs，向 Dashboard 提供了 WebApi，Predictors 提供了 TimeSeries API&lt;/li>
&lt;li>Dashboard: 基于 TDesign&amp;rsquo;s Starter 脚手架研发的前端项目，提供了易于上手的产品功能&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Fadvisor&lt;/strong>&lt;/p>
&lt;p>Fadvisor 提供一组 Exporter 计算集群云资源的计费和账单数据并存储到你的监控系统，比如 Prometheus。Fadvisor 通过 &lt;code>Cloud Provider&lt;/code> 支持了多云计费的 API。&lt;/p>
&lt;p>&lt;strong>Metric Adapter&lt;/strong>&lt;/p>
&lt;p>Metric Adapter 实现了一个 &lt;code>Custom Metric Apiserver&lt;/code>. Metric Adapter 读取 CRDs 信息并提供基于 &lt;code>Custom/External Metric API&lt;/code> 的 HPA Metric 的数据。&lt;/p>
&lt;p>&lt;strong>Crane Agent&lt;/strong>&lt;/p>
&lt;p>Crane Agent 通过 &lt;code>DaemonSet&lt;/code> 部署在集群的节点上。&lt;/p>
&lt;h2 id="repositories">Repositories&lt;/h2>
&lt;p>Crane is composed of the following components:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gocrane/crane/tree/main/cmd/craned">craned&lt;/a> - main crane control plane.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/crane/tree/main/cmd/metric-adapter">metric-adaptor&lt;/a> - Metric server for driving the scaling.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/crane/tree/main/cmd/crane-agent">crane-agent&lt;/a> - Ensure critical workloads SLO based on abnormally detection.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/api">api&lt;/a> - This repository defines component-level APIs for the Crane platform.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/fadvisor">fadvisor&lt;/a> - Financial advisor which collect resource prices from cloud API.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/crane-scheduler">crane-scheduler&lt;/a> - A Kubernetes scheduler which can schedule pod based on actual node load.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/kubectl-crane">kubectl-crane&lt;/a> - Kubectl plugin for crane, including recommendation and cost estimate.&lt;/li>
&lt;/ul></description></item></channel></rss>